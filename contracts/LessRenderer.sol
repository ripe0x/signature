// SPDX-License-Identifier: MIT
pragma solidity ^0.8.26;

import {Ownable} from "solady/auth/Ownable.sol";
import {Base64} from "solady/utils/Base64.sol";
import {LibString} from "solady/utils/LibString.sol";

import {ILessRenderer} from "./ILessRenderer.sol";

/// @title IScriptyBuilderV2
/// @notice Minimal interface for scripty.sol builder
interface IScriptyBuilderV2 {
    enum HTMLTagType {
        useTagOpenAndClose,
        script,
        scriptBase64DataURI,
        scriptGZIPBase64DataURI,
        scriptPNGBase64DataURI
    }

    struct HTMLTag {
        string name;
        address contractAddress;
        bytes contractData;
        HTMLTagType tagType;
        bytes tagOpen;
        bytes tagClose;
        bytes tagContent;
    }

    struct HTMLRequest {
        HTMLTag[] headTags;
        HTMLTag[] bodyTags;
    }

    function getHTMLString(HTMLRequest memory htmlRequest) external view returns (string memory);
    function getEncodedHTMLString(HTMLRequest memory htmlRequest) external view returns (string memory);
}

/// @title IScriptyStorage
/// @notice Minimal interface for scripty.sol storage
interface IScriptyStorage {
    function getScript(string memory name, bytes memory data) external view returns (bytes memory);
}

/// @title ILess
/// @notice Minimal interface for reading data from the Less NFT contract
interface ILess {
    struct Fold {
        uint64 startTime;
        uint64 endTime;
        uint64 strategyBlock;
    }

    struct TokenData {
        uint64 foldId;
        bytes32 seed;
    }

    function getFoldId(uint256 tokenId) external view returns (uint256);
    function getSeed(uint256 tokenId) external view returns (bytes32);
    function getFold(uint256 foldId) external view returns (Fold memory);
    function getTokenData(uint256 tokenId) external view returns (TokenData memory);
    function strategy() external view returns (address);
}

/// @title IStrategy
/// @notice Minimal interface for reading strategy supply
interface IStrategy {
    function totalSupply() external view returns (uint256);
}

/// @title LessRenderer
/// @notice Renders metadata and animation_url for Less NFTs using scripty.sol
contract LessRenderer is ILessRenderer, Ownable {
    using LibString for uint256;
    using LibString for bytes32;

    /*//////////////////////////////////////////////////////////////
                                 EVENTS
    //////////////////////////////////////////////////////////////*/

    event LessContractUpdated(address newLess);
    event ScriptyBuilderUpdated(address newBuilder);
    event ScriptyStorageUpdated(address newStorage);
    event ScriptNameUpdated(string newName);
    event BaseImageURLUpdated(string newURL);

    /*//////////////////////////////////////////////////////////////
                                 ERRORS
    //////////////////////////////////////////////////////////////*/

    error TokenDoesNotExist();

    /*//////////////////////////////////////////////////////////////
                            STATE VARIABLES
    //////////////////////////////////////////////////////////////*/

    /// @notice The Less NFT contract
    address public less;

    /// @notice ScriptyBuilderV2 contract address
    address public scriptyBuilder;

    /// @notice ScriptyStorage contract address (where the JS is stored)
    address public scriptyStorage;

    /// @notice Name of the script stored in ScriptyStorage
    string public scriptName;

    /// @notice Base URL for static images (e.g., "https://myserver.com/less/")
    string public baseImageURL;

    /// @notice Project description for metadata
    string public constant DESCRIPTION =
        "less is a generative art collection tied to a recursive strategy token. "
        "Each token represents a fold event - a moment when the strategy bought and burned its own supply. "
        "The visual is generated by simulating paper folding, drawing only where fold lines intersect.";

    /*//////////////////////////////////////////////////////////////
                              CONSTRUCTOR
    //////////////////////////////////////////////////////////////*/

    /// @param _less Address of the Less NFT contract
    /// @param _scriptyBuilder Address of ScriptyBuilderV2
    /// @param _scriptyStorage Address of ScriptyStorage
    /// @param _scriptName Name of the uploaded JS script in storage
    /// @param _baseImageURL Base URL for static images
    /// @param _owner Contract owner
    constructor(
        address _less,
        address _scriptyBuilder,
        address _scriptyStorage,
        string memory _scriptName,
        string memory _baseImageURL,
        address _owner
    ) {
        less = _less;
        scriptyBuilder = _scriptyBuilder;
        scriptyStorage = _scriptyStorage;
        scriptName = _scriptName;
        baseImageURL = _baseImageURL;

        _initializeOwner(_owner);
    }

    /*//////////////////////////////////////////////////////////////
                           MAIN ENTRY POINT
    //////////////////////////////////////////////////////////////*/

    /// @notice Returns the complete tokenURI as a data URI
    /// @param tokenId The token to generate metadata for
    /// @return A data:application/json;base64,... URI
    function tokenURI(uint256 tokenId) external view override returns (string memory) {
        // Get token data from the Less contract
        ILess.TokenData memory token = ILess(less).getTokenData(tokenId);
        ILess.Fold memory fold = ILess(less).getFold(token.foldId);

        // Build the metadata JSON
        string memory json = _buildMetadataJSON(tokenId, token, fold);

        // Encode as base64 data URI
        return string(abi.encodePacked(
            "data:application/json;base64,",
            Base64.encode(bytes(json))
        ));
    }

    /*//////////////////////////////////////////////////////////////
                          METADATA BUILDING
    //////////////////////////////////////////////////////////////*/

    /// @notice Builds the complete metadata JSON string
    function _buildMetadataJSON(
        uint256 tokenId,
        ILess.TokenData memory token,
        ILess.Fold memory fold
    ) internal view returns (string memory) {
        string memory animationURL = _buildAnimationURL(tokenId, token.seed);
        string memory imageURL = _buildImageURL(tokenId);
        string memory attributes = _buildAttributes(token, fold);

        return string(abi.encodePacked(
            '{"name":"less #',
            tokenId.toString(),
            '","description":"',
            DESCRIPTION,
            '","image":"',
            imageURL,
            '","animation_url":"',
            animationURL,
            '","attributes":',
            attributes,
            '}'
        ));
    }

    /// @notice Builds the static image URL
    function _buildImageURL(uint256 tokenId) internal view returns (string memory) {
        return string(abi.encodePacked(baseImageURL, tokenId.toString(), ".png"));
    }

    /// @notice Builds the animation_url using scripty.sol
    /// @dev Returns a data:text/html;base64,... URI
    function _buildAnimationURL(uint256 tokenId, bytes32 seed) internal view returns (string memory) {
        // Build HTML with scripty
        IScriptyBuilderV2.HTMLRequest memory request = _buildHTMLRequest(tokenId, seed);
        string memory encodedHTML = IScriptyBuilderV2(scriptyBuilder).getEncodedHTMLString(request);

        return string(abi.encodePacked("data:text/html;base64,", encodedHTML));
    }

    /// @notice Constructs the HTMLRequest for scripty builder
    function _buildHTMLRequest(
        uint256 tokenId,
        bytes32 seed
    ) internal view returns (IScriptyBuilderV2.HTMLRequest memory) {
        // Create head tags (inject seed as a global variable)
        IScriptyBuilderV2.HTMLTag[] memory headTags = new IScriptyBuilderV2.HTMLTag[](2);

        // Meta viewport for proper scaling
        headTags[0] = IScriptyBuilderV2.HTMLTag({
            name: "",
            contractAddress: address(0),
            contractData: "",
            tagType: IScriptyBuilderV2.HTMLTagType.useTagOpenAndClose,
            tagOpen: '<meta charset="utf-8"><meta name="viewport" content="width=device-width,initial-scale=1">',
            tagClose: "",
            tagContent: ""
        });

        // Inject seed and tokenId as global JS variables
        headTags[1] = IScriptyBuilderV2.HTMLTag({
            name: "",
            contractAddress: address(0),
            contractData: "",
            tagType: IScriptyBuilderV2.HTMLTagType.useTagOpenAndClose,
            tagOpen: "<script>",
            tagClose: "</script>",
            tagContent: bytes(_buildSeedScript(tokenId, seed))
        });

        // Create body tags (the main script from storage)
        IScriptyBuilderV2.HTMLTag[] memory bodyTags = new IScriptyBuilderV2.HTMLTag[](1);

        bodyTags[0] = IScriptyBuilderV2.HTMLTag({
            name: scriptName,
            contractAddress: scriptyStorage,
            contractData: "",
            tagType: IScriptyBuilderV2.HTMLTagType.script,
            tagOpen: "",
            tagClose: "",
            tagContent: ""
        });

        return IScriptyBuilderV2.HTMLRequest({
            headTags: headTags,
            bodyTags: bodyTags
        });
    }

    /// @notice Builds the inline script that sets global seed/tokenId variables
    function _buildSeedScript(uint256 tokenId, bytes32 seed) internal pure returns (string memory) {
        return string(abi.encodePacked(
            "window.LESS_TOKEN_ID=",
            tokenId.toString(),
            ";window.LESS_SEED=\"",
            _bytes32ToHexString(seed),
            "\";"
        ));
    }

    /// @notice Builds the attributes array for metadata
    function _buildAttributes(
        ILess.TokenData memory token,
        ILess.Fold memory fold
    ) internal view returns (string memory) {
        // Get strategy supply if available
        string memory supplyAttr = "";
        try IStrategy(ILess(less).strategy()).totalSupply() returns (uint256 supply) {
            supplyAttr = string(abi.encodePacked(
                ',{"trait_type":"Strategy Supply","value":',
                supply.toString(),
                '}'
            ));
        } catch {}

        return string(abi.encodePacked(
            '[{"trait_type":"Fold ID","value":',
            uint256(token.foldId).toString(),
            '},{"trait_type":"Seed","value":"',
            _bytes32ToHexString(token.seed),
            '"},{"trait_type":"Strategy Block","value":',
            uint256(fold.strategyBlock).toString(),
            '},{"trait_type":"Window Start","display_type":"date","value":',
            uint256(fold.startTime).toString(),
            '},{"trait_type":"Window End","display_type":"date","value":',
            uint256(fold.endTime).toString(),
            '}',
            supplyAttr,
            ']'
        ));
    }

    /// @notice Converts bytes32 to hex string with 0x prefix
    function _bytes32ToHexString(bytes32 data) internal pure returns (string memory) {
        bytes memory alphabet = "0123456789abcdef";
        bytes memory str = new bytes(66); // 0x + 64 hex chars
        str[0] = "0";
        str[1] = "x";
        for (uint256 i = 0; i < 32; i++) {
            str[2 + i * 2] = alphabet[uint8(data[i] >> 4)];
            str[3 + i * 2] = alphabet[uint8(data[i] & 0x0f)];
        }
        return string(str);
    }

    /*//////////////////////////////////////////////////////////////
                           ADMIN FUNCTIONS
    //////////////////////////////////////////////////////////////*/

    /// @notice Update the Less NFT contract address
    function setLessContract(address _less) external onlyOwner {
        less = _less;
        emit LessContractUpdated(_less);
    }

    /// @notice Update the ScriptyBuilder address
    function setScriptyBuilder(address _scriptyBuilder) external onlyOwner {
        scriptyBuilder = _scriptyBuilder;
        emit ScriptyBuilderUpdated(_scriptyBuilder);
    }

    /// @notice Update the ScriptyStorage address
    function setScriptyStorage(address _scriptyStorage) external onlyOwner {
        scriptyStorage = _scriptyStorage;
        emit ScriptyStorageUpdated(_scriptyStorage);
    }

    /// @notice Update the script name in storage
    function setScriptName(string memory _scriptName) external onlyOwner {
        scriptName = _scriptName;
        emit ScriptNameUpdated(_scriptName);
    }

    /// @notice Update the base image URL
    function setBaseImageURL(string memory _baseImageURL) external onlyOwner {
        baseImageURL = _baseImageURL;
        emit BaseImageURLUpdated(_baseImageURL);
    }
}
