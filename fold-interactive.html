<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Fold - Interactive Artwork</title>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, monospace;
      background: #0a0a0a;
      color: #e0e0e0;
      min-height: 100vh;
      display: flex;
      align-items: center;
      justify-content: center;
      overflow: hidden;
    }

    .artwork-container {
      position: relative;
      /* A4 aspect ratio */
      width: min(90vw, calc(90vh * 1200 / 1697));
      height: min(90vh, calc(90vw * 1697 / 1200));
    }

    /* Background canvas layer */
    .artwork-bg {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      pointer-events: none;
    }

    /* Character layer */
    .artwork-chars {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      overflow: hidden;
    }

    /* Individual character */
    .fold-char {
      position: absolute;
      cursor: default;
      user-select: none;
      font-family: "FoldMono", "Courier New", Courier, monospace;
      line-height: 1;
      white-space: pre;
      transition: transform 0.05s ease-out;
    }

    .fold-char:hover {
      /* Subtle hint that it's interactive */
      filter: brightness(1.1);
    }

    .fold-char.dragging {
      cursor: grabbing;
      z-index: 1000;
      filter: brightness(1.2);
      transition: none;
    }

    .fold-char.editing {
      cursor: text;
    }

    .fold-char.editing::after {
      content: '';
      position: absolute;
      left: 0;
      top: 10%;
      width: 2px;
      height: 80%;
      background: currentColor;
      animation: cursor-blink 1s step-end infinite;
    }

    @keyframes cursor-blink {
      0%, 100% { opacity: 1; }
      50% { opacity: 0; }
    }

    /* Controls overlay */
    .controls {
      position: fixed;
      top: 16px;
      left: 16px;
      display: flex;
      gap: 8px;
      z-index: 100;
    }

    .controls button {
      padding: 8px 12px;
      background: rgba(255,255,255,0.1);
      border: 1px solid rgba(255,255,255,0.2);
      border-radius: 4px;
      color: #fff;
      font-size: 12px;
      cursor: pointer;
      transition: background 0.2s;
    }

    .controls button:hover {
      background: rgba(255,255,255,0.2);
    }

    /* Seed display */
    .seed-display {
      position: fixed;
      bottom: 16px;
      left: 16px;
      font-family: monospace;
      font-size: 11px;
      color: #666;
      z-index: 100;
    }
  </style>
</head>
<body>
  <div class="controls">
    <button id="randomBtn">Random</button>
    <button id="resetBtn">Reset</button>
    <button id="exportBtn">Export SVG</button>
  </div>

  <div class="artwork-container" id="artworkContainer">
    <canvas class="artwork-bg" id="bgCanvas"></canvas>
    <div class="artwork-chars" id="charLayer"></div>
  </div>

  <div class="seed-display" id="seedDisplay"></div>

  <script type="module">
    import {
      generateAllParams,
      extractCharacterData as extractChars,
      REFERENCE_WIDTH,
      REFERENCE_HEIGHT,
      DRAWING_MARGIN,
      CHAR_WIDTH_RATIO,
      FONT_STACK,
      ONCHAIN_FONT_DATA_URI,
      ONCHAIN_FONT_NAME,
    } from './web/fold-core.js';

    // Load the on-chain font
    async function loadFont() {
      try {
        const font = new FontFace(ONCHAIN_FONT_NAME, `url(${ONCHAIN_FONT_DATA_URI})`);
        await font.load();
        document.fonts.add(font);
      } catch (e) {
        console.warn('Could not load on-chain font, using fallback');
      }
    }

    // State
    let currentSeed = Math.floor(Math.random() * 999999) + 1;
    let currentFolds = 50;
    let currentState = null;
    let charData = null;
    let charElements = [];
    let originalPositions = new Map();

    // Text buffer - all characters as a single flowing text
    let textBuffer = [];
    let cursorIndex = -1;
    let isEditing = false;

    // DOM elements
    const artworkContainer = document.getElementById('artworkContainer');
    const bgCanvas = document.getElementById('bgCanvas');
    const charLayer = document.getElementById('charLayer');
    const seedDisplay = document.getElementById('seedDisplay');
    const randomBtn = document.getElementById('randomBtn');
    const resetBtn = document.getElementById('resetBtn');
    const exportBtn = document.getElementById('exportBtn');

    // Drag state
    let dragState = null;

    // Hidden input for capturing text
    let hiddenInput = null;

    // Render background (texture only) on canvas
    function renderBackground(canvas, background, width, height) {
      const ctx = canvas.getContext('2d');
      const dpr = window.devicePixelRatio || 1;

      canvas.width = width * dpr;
      canvas.height = height * dpr;
      canvas.style.width = width + 'px';
      canvas.style.height = height + 'px';

      ctx.setTransform(dpr, 0, 0, dpr, 0, 0);

      // Fill background
      ctx.fillStyle = background.color;
      ctx.fillRect(0, 0, width, height);

      // Add texture
      const scaleX = width / REFERENCE_WIDTH;
      const refTextureFontSize = 15;
      const textureFontSize = refTextureFontSize * scaleX;

      ctx.font = `${textureFontSize}px ${FONT_STACK}`;
      ctx.fillStyle = background.textureColor;
      ctx.globalAlpha = background.textureOpacity;

      const charWidth = textureFontSize * CHAR_WIDTH_RATIO;
      const charHeight = textureFontSize * 1.13;

      for (let y = 0; y < height + charHeight; y += charHeight) {
        for (let x = 0; x < width + charWidth; x += charWidth) {
          ctx.fillText('░', x, y + charHeight);
        }
      }

      ctx.globalAlpha = 1.0;
    }

    // Create DOM elements for characters
    function renderCharacters(characters) {
      // Stop any active editing first
      stopEditing();

      charLayer.innerHTML = '';
      charElements = [];
      originalPositions.clear();
      textBuffer = [];

      // Reset hiddenInput since innerHTML cleared it
      hiddenInput = null;

      for (let i = 0; i < characters.length; i++) {
        const c = characters[i];
        const el = document.createElement('span');
        el.className = 'fold-char';
        el.textContent = c.char;
        el.dataset.id = c.id;
        el.dataset.index = i;
        el.dataset.row = c.row;
        el.dataset.col = c.col;

        el.style.left = c.x + 'px';
        el.style.top = c.y + 'px';
        el.style.fontSize = c.fontSize + 'px';
        el.style.color = c.color;
        el.style.width = c.width + 'px';
        el.style.height = c.height + 'px';

        // Store original position and character
        originalPositions.set(c.id, { x: c.x, y: c.y, char: c.char });

        // Build text buffer
        textBuffer.push({
          char: c.char,
          originalChar: c.char,
          el,
          color: c.color,
        });

        charLayer.appendChild(el);
        charElements.push(el);
      }

      // Create hidden input for text capture
      hiddenInput = document.createElement('input');
      hiddenInput.type = 'text';
      hiddenInput.style.cssText = `
        position: absolute;
        opacity: 0;
        pointer-events: none;
        width: 1px;
        height: 1px;
      `;
      hiddenInput.addEventListener('input', onTextInput);
      hiddenInput.addEventListener('keydown', onTextKeyDown);
      hiddenInput.addEventListener('blur', onTextBlur);
      charLayer.appendChild(hiddenInput);
    }

    // Update DOM elements from text buffer
    function syncBufferToDOM() {
      for (let i = 0; i < textBuffer.length; i++) {
        const entry = textBuffer[i];
        entry.el.textContent = entry.char;
      }
    }

    // Handle text input
    function onTextInput(e) {
      if (!isEditing || cursorIndex < 0) return;

      const typed = e.data;
      if (!typed) return;

      // Replace characters starting at cursor (overwrite mode)
      for (let i = 0; i < typed.length; i++) {
        const replaceAt = cursorIndex + i;
        if (replaceAt >= textBuffer.length) break;

        // Update buffer and show character
        textBuffer[replaceAt].char = typed[i];
        textBuffer[replaceAt].el.textContent = typed[i];
      }

      // Move cursor forward (this will clear the new position)
      const newIndex = Math.min(cursorIndex + typed.length, textBuffer.length - 1);
      if (newIndex !== cursorIndex) {
        cursorIndex = newIndex;
        updateCursorHighlight();
      }

      // Clear input for next character
      hiddenInput.value = '';
    }

    // Helper to restore current cell before moving
    function restoreCurrentCell() {
      if (cursorIndex >= 0 && cursorIndex < textBuffer.length) {
        const entry = textBuffer[cursorIndex];
        entry.el.textContent = entry.char;
      }
    }

    // Handle special keys
    function onTextKeyDown(e) {
      if (!isEditing) return;

      if (e.key === 'Escape') {
        stopEditing();
        return;
      }

      if (e.key === 'ArrowLeft') {
        e.preventDefault();
        if (cursorIndex > 0) {
          restoreCurrentCell();
          cursorIndex = cursorIndex - 1;
          updateCursorHighlight();
        }
      } else if (e.key === 'ArrowRight') {
        e.preventDefault();
        if (cursorIndex < textBuffer.length - 1) {
          restoreCurrentCell();
          cursorIndex = cursorIndex + 1;
          updateCursorHighlight();
        }
      } else if (e.key === 'ArrowUp') {
        e.preventDefault();
        const current = charData.characters[cursorIndex];
        if (current) {
          const targetRow = current.row - 1;
          const targetCol = current.col;
          const above = charData.characters.findIndex(
            c => c.row === targetRow && c.col === targetCol
          );
          if (above >= 0) {
            restoreCurrentCell();
            cursorIndex = above;
            updateCursorHighlight();
          }
        }
      } else if (e.key === 'ArrowDown') {
        e.preventDefault();
        const current = charData.characters[cursorIndex];
        if (current) {
          const targetRow = current.row + 1;
          const targetCol = current.col;
          const below = charData.characters.findIndex(
            c => c.row === targetRow && c.col === targetCol
          );
          if (below >= 0) {
            restoreCurrentCell();
            cursorIndex = below;
            updateCursorHighlight();
          }
        }
      } else if (e.key === 'Backspace') {
        e.preventDefault();
        // Restore original char at current position and move back
        textBuffer[cursorIndex].char = textBuffer[cursorIndex].originalChar;
        textBuffer[cursorIndex].el.textContent = textBuffer[cursorIndex].originalChar;
        if (cursorIndex > 0) {
          cursorIndex = cursorIndex - 1;
          updateCursorHighlight();
        }
      } else if (e.key === 'Delete') {
        e.preventDefault();
        // Restore original char at current position, stay in place
        textBuffer[cursorIndex].char = textBuffer[cursorIndex].originalChar;
        // Keep cell empty since we're still editing here
      }
    }

    // Update cursor highlight
    function updateCursorHighlight() {
      // Remove highlight from all
      charElements.forEach(el => el.classList.remove('editing'));

      // Add to current and clear it
      if (cursorIndex >= 0 && cursorIndex < charElements.length) {
        const entry = textBuffer[cursorIndex];
        if (entry) {
          entry.el.textContent = '';
        }
        charElements[cursorIndex].classList.add('editing');

        // Position hidden input near cursor for mobile keyboards
        const el = charElements[cursorIndex];
        hiddenInput.style.left = el.style.left;
        hiddenInput.style.top = el.style.top;
      }
    }

    // Start editing at a position
    function startEditing(index) {
      isEditing = true;
      cursorIndex = index;

      // Clear the character to show empty cell with cursor
      const entry = textBuffer[index];
      if (entry) {
        entry.el.textContent = '';
      }

      updateCursorHighlight();
      hiddenInput.focus();
    }

    // Stop editing
    function stopEditing() {
      // Restore character from buffer if cell is empty
      if (cursorIndex >= 0 && cursorIndex < textBuffer.length) {
        const entry = textBuffer[cursorIndex];
        if (entry && entry.el.textContent === '') {
          entry.el.textContent = entry.char;
        }
      }

      isEditing = false;
      cursorIndex = -1;
      charElements.forEach(el => el.classList.remove('editing'));
      if (hiddenInput) {
        hiddenInput.blur();
      }
    }

    // Handle blur
    function onTextBlur() {
      // Small delay to allow click events to process
      setTimeout(() => {
        if (hiddenInput && !hiddenInput.matches(':focus')) {
          stopEditing();
        }
      }, 100);
    }

    // Initialize drag handlers
    function initDragHandlers() {
      charLayer.addEventListener('mousedown', onMouseDown);
      charLayer.addEventListener('touchstart', onTouchStart, { passive: false });
      document.addEventListener('mousemove', onMouseMove);
      document.addEventListener('touchmove', onTouchMove, { passive: false });
      document.addEventListener('mouseup', onMouseUp);
      document.addEventListener('touchend', onTouchEnd);
      charLayer.addEventListener('dblclick', onDoubleClick);
    }

    function onMouseDown(e) {
      const target = e.target.closest('.fold-char');
      if (!target) return;

      e.preventDefault();
      startDrag(target, e.clientX, e.clientY);
    }

    function onTouchStart(e) {
      const target = e.target.closest('.fold-char');
      if (!target) return;

      e.preventDefault();
      const touch = e.touches[0];
      startDrag(target, touch.clientX, touch.clientY);
    }

    function startDrag(el, clientX, clientY) {
      const rect = el.getBoundingClientRect();
      const containerRect = artworkContainer.getBoundingClientRect();

      dragState = {
        el,
        startX: clientX,
        startY: clientY,
        offsetX: clientX - rect.left,
        offsetY: clientY - rect.top,
        containerRect,
        originalLeft: parseFloat(el.style.left),
        originalTop: parseFloat(el.style.top),
      };

      el.classList.add('dragging');
    }

    function onMouseMove(e) {
      if (!dragState) return;
      moveDrag(e.clientX, e.clientY);
    }

    function onTouchMove(e) {
      if (!dragState) return;
      e.preventDefault();
      const touch = e.touches[0];
      moveDrag(touch.clientX, touch.clientY);
    }

    function moveDrag(clientX, clientY) {
      const { el, containerRect, offsetX, offsetY } = dragState;

      // Calculate new position relative to container
      const x = clientX - containerRect.left - offsetX;
      const y = clientY - containerRect.top - offsetY;

      el.style.left = x + 'px';
      el.style.top = y + 'px';
    }

    function onMouseUp() {
      endDrag();
    }

    function onTouchEnd() {
      endDrag();
    }

    function endDrag() {
      if (dragState) {
        dragState.el.classList.remove('dragging');
        dragState = null;
      }
    }

    // Double-click to start editing (flowing text mode)
    function onDoubleClick(e) {
      const target = e.target.closest('.fold-char');
      if (!target) return;

      e.preventDefault();
      const index = parseInt(target.dataset.index, 10);
      if (!isNaN(index)) {
        startEditing(index);
      }
    }

    // Reset positions and text
    function resetPositions() {
      stopEditing();
      for (let i = 0; i < charElements.length; i++) {
        const el = charElements[i];
        const id = el.dataset.id;
        const original = originalPositions.get(id);
        if (original) {
          el.style.left = original.x + 'px';
          el.style.top = original.y + 'px';
          // Reset text
          if (textBuffer[i]) {
            textBuffer[i].char = original.char;
          }
          el.textContent = original.char;
        }
      }
    }

    // Generate new random artwork
    function generateRandom() {
      currentSeed = Math.floor(Math.random() * 999999) + 1;
      currentFolds = Math.floor(Math.random() * 100) + 1;
      render();
    }

    // Export as SVG
    function exportSVG() {
      if (!charData) return;

      const rect = artworkContainer.getBoundingClientRect();
      const width = rect.width;
      const height = rect.height;

      let svg = `<?xml version="1.0" encoding="UTF-8"?>
<svg xmlns="http://www.w3.org/2000/svg" width="${width}" height="${height}" viewBox="0 0 ${width} ${height}">
  <rect width="100%" height="100%" fill="${charData.background.color}"/>
`;

      for (const el of charElements) {
        const x = parseFloat(el.style.left);
        const y = parseFloat(el.style.top);
        const fontSize = parseFloat(el.style.fontSize);
        const color = el.style.color;
        const char = el.textContent;

        // SVG text uses baseline, adjust y
        const adjustedY = y + fontSize;

        svg += `  <text x="${x}" y="${adjustedY}" font-family="Courier New, monospace" font-size="${fontSize}" fill="${color}">${char}</text>\n`;
      }

      svg += `</svg>`;

      const blob = new Blob([svg], { type: 'image/svg+xml' });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = `fold-${currentSeed}.svg`;
      a.click();
      URL.revokeObjectURL(url);
    }

    // Export as PNG - captures current state including edits
    function downloadPNG() {
      if (!charData) return;

      const rect = artworkContainer.getBoundingClientRect();
      const width = rect.width;
      const height = rect.height;
      const dpr = window.devicePixelRatio || 2;

      // Create a canvas to composite everything
      const exportCanvas = document.createElement('canvas');
      exportCanvas.width = width * dpr;
      exportCanvas.height = height * dpr;
      const ctx = exportCanvas.getContext('2d');
      ctx.setTransform(dpr, 0, 0, dpr, 0, 0);

      // Draw background
      ctx.fillStyle = charData.background.color;
      ctx.fillRect(0, 0, width, height);

      // Draw background texture
      const scaleX = width / REFERENCE_WIDTH;
      const refTextureFontSize = 15;
      const textureFontSize = refTextureFontSize * scaleX;
      ctx.font = `${textureFontSize}px ${FONT_STACK}`;
      ctx.fillStyle = charData.background.textureColor;
      ctx.globalAlpha = charData.background.textureOpacity;
      const texCharWidth = textureFontSize * CHAR_WIDTH_RATIO;
      const texCharHeight = textureFontSize * 1.13;
      for (let y = 0; y < height + texCharHeight; y += texCharHeight) {
        for (let x = 0; x < width + texCharWidth; x += texCharWidth) {
          ctx.fillText('░', x, y + texCharHeight);
        }
      }
      ctx.globalAlpha = 1.0;

      // Draw characters at their current positions with current text
      ctx.textBaseline = 'top';
      for (let i = 0; i < charElements.length; i++) {
        const el = charElements[i];
        const x = parseFloat(el.style.left);
        const y = parseFloat(el.style.top);
        const fontSize = parseFloat(el.style.fontSize);
        const color = el.style.color;
        const char = el.textContent; // Current text (may be edited)

        ctx.font = `${fontSize}px ${FONT_STACK}`;
        ctx.fillStyle = color;
        ctx.fillText(char, x, y);
      }

      // Download
      exportCanvas.toBlob((blob) => {
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = `fold-${currentSeed}-edit.png`;
        a.click();
        URL.revokeObjectURL(url);
      }, 'image/png');
    }

    // Global keyboard shortcuts
    function initKeyboardShortcuts() {
      document.addEventListener('keydown', (e) => {
        // Cmd/Ctrl+S - Download PNG (works even while editing)
        if ((e.metaKey || e.ctrlKey) && e.key === 's') {
          e.preventDefault();
          downloadPNG();
          return;
        }

        // Don't trigger other shortcuts while editing text
        if (isEditing) return;

        // R - Random
        if (e.key === 'r' || e.key === 'R') {
          e.preventDefault();
          generateRandom();
          return;
        }

        // Escape - Reset
        if (e.key === 'Escape') {
          e.preventDefault();
          resetPositions();
          return;
        }
      });
    }

    // Main render function
    function render() {
      const rect = artworkContainer.getBoundingClientRect();
      const width = rect.width;
      const height = rect.height;

      // Generate params and state
      const params = generateAllParams(currentSeed, REFERENCE_WIDTH, REFERENCE_HEIGHT, 0, currentFolds);
      currentState = {
        seed: currentSeed,
        foldCount: currentFolds,
        params,
      };

      // Extract character data using fold simulation
      charData = extractChars(currentState, width, height);

      // Render background
      renderBackground(bgCanvas, charData.background, width, height);

      // Render characters as DOM elements
      renderCharacters(charData.characters);

      // Update seed display
      seedDisplay.textContent = `Seed: ${currentSeed} | Folds: ${currentFolds}`;
    }

    // Initialize
    async function init() {
      await loadFont();

      // Get seed from URL if present
      const urlParams = new URLSearchParams(window.location.search);
      if (urlParams.has('seed')) {
        currentSeed = parseInt(urlParams.get('seed')) || currentSeed;
      }
      if (urlParams.has('folds')) {
        currentFolds = parseInt(urlParams.get('folds')) || currentFolds;
      }

      initDragHandlers();
      initKeyboardShortcuts();

      randomBtn.addEventListener('click', generateRandom);
      resetBtn.addEventListener('click', resetPositions);
      exportBtn.addEventListener('click', exportSVG);

      // Initial render
      render();

      // Re-render on resize
      window.addEventListener('resize', () => {
        render();
      });
    }

    init();
  </script>
</body>
</html>
